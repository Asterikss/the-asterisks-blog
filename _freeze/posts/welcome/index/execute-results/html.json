{
  "hash": "ad56ab8024803ae8f5cdf60b4ccf450c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"How to multiply matrixes wihout doing so?\"\nauthor: \"Andre Miro≈Ñczuk\"\ndate: \"2024-06-28\"\ncategories: [pytorch, numpy]\njupyter: python3\n---\n\n\nLets use these two simple 2 by 2 matrixes.\n\n![](./simple_matrixes2.png)\n\nAfter multiplying them we get:\n\n::: {#f45ba37a .cell execution_count=1}\n``` {.python .cell-code}\nimport torch\nm1 = torch.tensor([[1, 2], [3, 4]])\nm2 = torch.tensor([[3, 4], [1, 2]])\nm1@m2\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\ntensor([[ 5,  8],\n        [13, 20]])\n```\n:::\n:::\n\n\nSimple.  \nBut we've used a magic symbol `@`! That's a big no no.\n\nWhat is happening there?  \nHow about we dont do that.\n\nAs you probably know, looping over the whole matrix, mutiplying the\nelements one by one, summing them and then putting them in a new matrix of a\ncorrect size is a bad idea. \n\nInstead we will start by transposing the second matrix (rotating it over its 'identity' axis).\n\n::: {#f72830d9 .cell execution_count=2}\n``` {.python .cell-code}\nm2 = m2.T\nm2\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\ntensor([[3, 1],\n        [4, 2]])\n```\n:::\n:::\n\n\nimage\n\nWhy? We'll see in a bit.\n\nNow we want to add a dummy dimension to both matrixes. We want the first\nmatrix's shape to be 2 by 1 by 2 and the second to be 1 by 2 by 2.\n\nWe can just reshape them or achieve that by adding two pairs of brackets to the first one and one pair\nof brackets to the second.\n\nimage\n\n::: {#504fae1e .cell execution_count=3}\n``` {.python .cell-code}\nm1 = m1.reshape((2, 1, 2)) # torch.tensor([[[1, 2]], [[3, 4]]])\nm2 = m2.reshape((1, 2, 2)) # torch.tensor([[[3, 4], [1, 2]]])\n```\n:::\n\n\n::: {#29ac79d0 .cell execution_count=4}\n\n::: {.cell-output .cell-output-stdout}\n```\ntensor([[[1, 2]],\n\n        [[3, 4]]])\ntensor([[[3, 1],\n         [4, 2]]])\ntorch.Size([2, 1, 2]) torch.Size([1, 2, 2])\n```\n:::\n:::\n\n\nLet's multiply them now.\n\n::: {#4b2ed5f3 .cell execution_count=5}\n``` {.python .cell-code}\nm3 = m1 * m2\n```\n:::\n\n\nWhat will come out of it exactly?\n\nMultiplication rules tell us that multiplying a [2, 1, 2] matrix by a [1, 2, 2] one\nis indeed possible and will result in a [2, 2, 2] matrix.\n\n::: {.callout-tip appearance=\"simple\"}\n## Broadcasting rules\n* Each tensor has at least one dimension.\n* When iterating over the dimension sizes, starting at the trailing dimension,\n  the dimension sizes must either be equal, one of them is 1, or one of them does\n  not exist.\n:::\n\nAs we can see that operation doesn't brake any rules. Second dimention in the\nfirst matrix and first dimention in the second matrix will be expanded.\nImportantly, this does not make any copies of the data.\n\n::: {.callout-note appearance=\"simple\"}\nAs a side note it's good to remember that in-place operations do not allow the in-place\nmatrix (tensor) to change shape.\n:::\n\n<!-- ![](thumbnail.jpg) -->\n\n[about](about.qmd)\n\nSince this post doesn't specify an explicit `image`, the first image in the post will be used in the listing page of posts.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}