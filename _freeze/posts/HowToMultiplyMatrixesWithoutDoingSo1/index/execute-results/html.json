{
  "hash": "59825469f2cd96bd022e8ca087b8c4bf",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"How to multiply tensors wihout doing so? (1/2)\"\nauthor: \"Andre Miro≈Ñczuk\"\ndate: \"2024-06-28\"\ncategories: [pytorch, numpy]\njupyter: python3\n---\n\n\nLets use these two simple 2nd-order tensors.\n\n![](./simple_matrixes.png)\n\nAfter multiplying them we get:\n\n::: {#6c5c71dc .cell execution_count=1}\n``` {.python .cell-code}\nimport torch\nm1 = torch.tensor([[1, 2], [3, 4]])\nm2 = torch.tensor([[3, 4], [1, 2]])\nm1@m2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntensor([[ 5,  8],\n        [13, 20]])\n```\n:::\n:::\n\n\n![](./simple_matmul.png)\n\nSimple.\n\nBut we've used a magic symbol `@`! That's a big no no.\n\nWhat is happening there?\n\nHow about we dont do that.\n\nAs you probably know, looping over tensors, mutiplying elements one by one,\nsumming them and then putting them in a new tensor of a correct size is a bad\nidea. \n\nInstead we will start by transposing the second tensor (rotating it over its 'identity' axis).\n\n::: {#69887be6 .cell execution_count=2}\n``` {.python .cell-code}\nm2 = m2.T\nm2\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\ntensor([[3, 1],\n        [4, 2]])\n```\n:::\n:::\n\n\n![](./matrix_transpose.png)\n\nWhy? We'll see in a bit.\n\nNow we want to add a dummy dimension to both tensors. We want the first\ntensors's shape to be [2, 1, 2] and the second to be [1, 2, 2].\n\nWe can just reshape them or achieve that by adding two pairs of brackets to the first one and one pair\nof brackets to the second.\n\n::: {#6479fc7c .cell execution_count=3}\n``` {.python .cell-code}\nm1 = m1.reshape((2, 1, 2)) # torch.tensor([[[1, 2]], [[3, 4]]])\nm2 = m2.reshape((1, 2, 2)) # torch.tensor([[[3, 4], [1, 2]]])\n```\n:::\n\n\n![](./matrix_reshaping.png)\n\n::: {#880b8723 .cell execution_count=4}\n``` {.python .cell-code}\nm1, m2, m1.shape, m2.shape\n```\n:::\n\n\n::: {#0e67c9f5 .cell execution_count=5}\n\n::: {.cell-output .cell-output-stdout}\n```\ntensor([[[1, 2]],\n\n        [[3, 4]]])\ntensor([[[3, 1],\n         [4, 2]]])\ntorch.Size([2, 1, 2]) torch.Size([1, 2, 2])\n```\n:::\n:::\n\n\nLet's multiply them now (element-wise).\n\n::: {#b299a955 .cell execution_count=6}\n``` {.python .cell-code}\nm3 = m1 * m2\n```\n:::\n\n\nWhat will come out of it exactly?\n\nMultiplication rules tell us that multiplying a [2, 1, 2] tensor by a [1, 2, 2] one\nis indeed possible and will result in a [2, 2, 2] tensor.\n\n::: {.callout-tip appearance=\"simple\"}\n## Broadcasting rules\n* Each tensor has at least one dimension.\n* When iterating over the dimension sizes, starting at the trailing dimension,\n  the dimension sizes must either be equal, one of them is 1, or one of them does\n  not exist.\n:::\n\nAs we can see that this operation doesn't brake any rules. Second dimention in\nthe first tensor and first dimention in the second tensor will be expanded.\nImportantly, this does not make any copies of the data.\n\n::: {.callout-note appearance=\"simple\"}\nAs a side note it's good to remember that in-place operations do not allow the in-place\ntensor to change shape.\n:::\n\nMultiplication rules in this type of scenario can be a bit tricky at first, but\nhere it is quite streight forward.\n\n![](./m1_m2_stripped.png)\n\nHigh overview:  \nMultiply A by m2 and B by m2. Then just put them side by side. This again uses\nbroadcasting.\n\nYou can simplify it furher:  \n\n1. Multiply A * C. Then you multiply A * D and append it to the frist vector\n<!-- (since you're multiplying it with the same vector (A) as in the previous -->\n<!-- operation). -->\n\n![](./m1_m2_first_operation.png)\n\n2. Now do the same with B. B * C, B * D, append.\n\n![](./m1_m2_second_operation.png)\n\n3. Since B 'is in' a different dimension than A, the resulting tensor will be\nseperate from the previous one. They will be appended together as two 2 by 2\nblocks.\n\n![](./m1_m2_third_operation.png)\n\nBoth (1.) and (2.) will, sort of, take care of increasing the size of the second\ndimension of the second tensor to 2:  \n[2, 1, 2] -> [2, 2, 2]  \n(3.) will do the same but to the first demention of the first tensor:  \n[1, 2, 2] -> [2, 2, 2]\n\nWe need to do one last thing, that is to sum that tensor over its second\ndimension (last one).\n\n::: {#1ea32559 .cell execution_count=7}\n``` {.python .cell-code}\nm3.sum(dim=2)\n```\n:::\n\n\nThis will shrink all the vectors in the last dimension to scalars by summing\nall the numbers inside.\n\nThen, since the keepdim flag in `sum()` is set to `False` by default,\ndimensions of size 1 will be squizzed out, leaving us with a tensor of size [2,\n2].\n\n<!-- If we set it to `True` -> `m3.sum(dim=2, keepdim=True)`, the resulting -->\n<!-- tensor's shape would be [2, 2, 1]. -->\n\n<!-- ```{python} -->\n<!-- m3.sum(dim=2, keepdim=True).shape -->\n<!-- ``` -->\n\nFinal result, after the last dimension is squeezed out:\n\n::: {#e8709b44 .cell execution_count=8}\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\ntensor([[ 5,  8],\n        [13, 20]])\n```\n:::\n:::\n\n\n![](./simple_matmul.png)\n\nIt's exactly the same as with `@`!\n\nBut why?\n\nDoes it always work and is it really what happens under the hood?\n\nFind out in the [second part](../post-with-code/index.qmd) of this blog!\n\n<!-- change every occurace of matrix to tensor? -->\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}